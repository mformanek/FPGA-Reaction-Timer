<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Readme</title><style type="text/css"> * {margin:0; padding:0; text-indent:0; }
 p { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10pt; margin:0pt; }
 .s1 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8pt; }
 .s2 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 19pt; }
 .s3 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 13pt; }
 .s4 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 10.5pt; }
 .s5 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 .s6 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 8.5pt; }
 .s7 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 7.5pt; }
 .s8 { color: black; font-family:"Times New Roman", serif; font-style: normal; font-weight: normal; text-decoration: underline; font-size: 10pt; }
 .s13 { color: black; font-family:Arial, sans-serif; font-style: italic; font-weight: normal; text-decoration: none; font-size: 10pt; }
 .s14 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: 3pt; }
 .s15 { color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 6.5pt; vertical-align: -1pt; }
 li {display: block; }
 #l1 {padding-left: 0pt;counter-reset: c1 2; }
 #l1> li>*:first-child:before {counter-increment: c1; content: counter(c1, decimal)" "; color: black; font-style: normal; font-weight: normal; text-decoration: none; }
 #l1> li:first-child>*:first-child:before {counter-increment: c1 0;  }
 #l2 {padding-left: 0pt;counter-reset: c2 1; }
 #l2> li>*:first-child:before {counter-increment: c2; content: counter(c1, decimal)"."counter(c2, decimal)" "; color: black; font-family:"Bookman Old Style", serif; font-style: normal; font-weight: normal; text-decoration: none; font-size: 11pt; }
 #l2> li:first-child>*:first-child:before {counter-increment: c2 0;  }
</style></head><body><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">ECEN2350 D<span class="s1">IGITAL </span>L<span class="s1">OGIC </span>S<span class="s1">PRING </span>2016</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s2" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Project 3 - The Reaction Timer</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 2pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 12pt;padding-left: 194pt;text-indent: 0pt;line-height: 127%;text-align: center;">Milan Formanek SID-103017710 May 5, 2016</p><p class="s3" style="padding-top: 3pt;padding-left: 214pt;text-indent: 0pt;text-align: left;">1 I<span class="s4">NTRODUCTION</span></p><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">The goal of this project is to create a reaction timer using the DE0 FPGA board. To make this work I will use more advanced features like the 50 mHz clock provided by the DE0 board as well as counters a binary to BCD decoder and a pseudo random number generator.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-left: 230pt;text-indent: 0pt;text-align: left;">2 O<span class="s4">VERVIEW</span></p><p style="padding-top: 12pt;padding-left: 5pt;text-indent: 0pt;line-height: 114%;text-align: center;">When the user releases the reset button, the device waits a random amount of time then flashes the LED and times the delay it takes the user to depress the &quot;game&quot; button. The delay between the the reset and the led bilking is to prevent the user from anticipating the exact time the reaction timer starts, thus truly testing his or her reaction time. After the users reaction time has been recorded the resultant reaction time is displayed in decimal form on the 7 segment screen.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-bottom: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 2.1: Device diagram</p><p style="padding-left: 138pt;text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><ol id="l1"><ol id="l2"><li data-list-text="2.1"><p class="s5" style="padding-left: 219pt;text-indent: -21pt;text-align: left;">100 H<span class="s6">Z </span>C<span class="s6">LOCK </span>D<span class="s6">IVIDER</span></p><p class="s7" style="text-indent: 0pt;line-height: 9pt;text-align: left;">100</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">The 50 mHz on board clock the DE0 provides, needs to be stepped down to a 100 Hz in order to trigger the Timer logic every <span class="s8">&nbsp;</span><u>1</u><u> </u> of a second achieving the precision desired. This is implemented using a counter that overflows every</p><p style="padding-left: 6pt;text-indent: 0pt;text-align: center;">250000 cycles of the 50 mHz clock giving a final divided frequency of a 100 Hz.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 9pt;padding-bottom: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 2.2: 50mHz to 100Hz divider verilog hardware description</p><p style="padding-left: 98pt;text-indent: 0pt;text-align: left;"><span/></p></li><li data-list-text="2.2"><p class="s5" style="padding-top: 3pt;padding-left: 180pt;text-indent: -21pt;text-align: left;">P<span class="s6">SEUDO </span>R<span class="s6">ANDOM </span>N<span class="s6">UMBER </span>G<span class="s6">ENERATOR</span></p><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">Using a linear feedback shift register (LFSR) you can generate a sequence of pseudo random numbers. This is achieved by shifting the data set in a shift register and XORing certain outputs with each other. I want to generate a 10 bit random number, that will give me a max value of 1023 translating into the max go led delay of 10.23 sec. This is suitable to give enough of a range to provide enough randomness, but worst case scenario this still doesn’t let the user wait too long. Using the Xilinx application notes or xapp052.pdf table 3 I find the right outputs to XOR. A LFSR can only be classified as a pseudo random number generator as it traverses 2<i>n</i><i> </i><span class="s13">− </span>1 states before repeating itself. Where n is the light of the shift register. I our case this would be 2<span class="s14">10</span> <span class="s13">− </span>1 states. Another thing to note is that if the shift register gets filled with only 0s the machine will lock up in that state forever. This is due to the fact that 0 XOR 0 = 0.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-bottom: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 2.3: Pseudo Random Number Generator Logic verilog hardware description</p><p style="padding-left: 89pt;text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">In Fig 3.1you can see the register is prevented from initializing in the lock up 0 state by setting the output register d to 5 initially. The shift register shifts down one every clock cycle producing a &quot;fresh&quot; random number.</p><p style="padding-left: 18pt;text-indent: 0pt;line-height: 114%;text-align: center;">To test if the LFSR worked I had a runtime that captured a random number every time I pressed the button and displayed it on the screen. Fig. 2.4 below presents a sample of random numbers generated by the LFSR.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;line-height: 11pt;text-align: left;">Random numbers</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-left: 142pt;text-indent: -38pt;line-height: 128%;text-align: left;">Figure 2.4: Histogram of 10 sample random numbers from the generator 10</p><p style="padding-top: 3pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">9</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">8</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">7</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">6</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">5</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">4</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">3</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">2</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">1</p><p style="padding-top: 6pt;padding-left: 148pt;text-indent: 0pt;text-align: left;">0</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 19pt;text-indent: 0pt;text-align: center;">1  2  3  4  5  6  7  8  9  10</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.3"><p class="s5" style="padding-top: 4pt;padding-left: 245pt;text-indent: -21pt;text-align: left;">T<span class="s6">IMER </span>L<span class="s6">OGIC</span></p><p style="padding-top: 8pt;padding-left: 11pt;text-indent: 0pt;line-height: 114%;text-align: center;">The timer logic take care of the user input, flashing the go led, counting the time using the 100 Hz clock cycles and finally outputting the user reaction time in binary to the BCD decoder.</p><p style="padding-left: 19pt;text-indent: 0pt;line-height: 114%;text-align: center;">Fig 2.5 shows of the individual states of the reaction timer. The 10bit wide wire t represent the up to date &quot;fresh&quot; random number from the generator that is captured into the rdm register and led[9] represents the go led.</p><p style="padding-left: 11pt;text-indent: 0pt;line-height: 114%;text-align: center;">The number of clock cycles is stored in a 32 bit register. A number of this size will probably never get used and can’t even be properly displayed on a 4 digit screen without overflow, nevertheless the counter will count up that high.</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.4"><p class="s5" style="padding-left: 214pt;text-indent: -21pt;text-align: left;">B<span class="s6">INARY </span>T<span class="s6">O </span>B<span class="s6">CD </span>D<span class="s6">ECODER</span></p><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">The decoder gets a 14 bit number end converts it into 4 separate BCD digits. For this it uses the shift and add 3 method. The algorithm shifts the input and if the resultant shifted number is bigger than 4 it add 3 and then shift again. This process repeats itself until it has shifted the same amount of times as the input has binary digits.</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 2.5: State Diagram</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 73pt;text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-bottom: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 2.6: The Timer Logic verilog hardware description</p><p style="padding-left: 33pt;text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 9pt;padding-bottom: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 2.7: shift and add 3 algorithm</p><p style="padding-left: 45pt;text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Fig. 2.7 above gives a visual representation of how the algorithm works converting 1110<span class="s15">2</span> into BCD digits 1 and 4</p><p style="text-indent: 0pt;text-align: left;"><br/></p></li><li data-list-text="2.5"><p class="s5" style="padding-left: 225pt;text-indent: -21pt;text-align: left;">7 S<span class="s6">EGMENT DECODER</span></p></li></ol></ol><p style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">The decoder decodes input in the BCD (binary coded decimal) format to the 7 segment display. This is done using a bitmask on the led arrays that make up the screens themselves. The same logic was used in my project 1 and 2.</p><p class="s3" style="padding-top: 3pt;padding-left: 217pt;text-indent: 0pt;text-align: left;">3 U<span class="s4">SER </span>M<span class="s4">ANUAL</span></p><p style="padding-top: 12pt;padding-left: 6pt;text-indent: 0pt;line-height: 114%;text-align: center;">After the device is turned on it waits for the user to press the reset button. Once the reset button is released (neg edge) the go led flashes after a random time interval. The device times how long it takes the user to depress (pos edge) the game button after the go led has turned on. The result is displayed on the 7 segment screen in seconds. Fig 3.1 shows the physical layout of the device.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-bottom: 2pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 3.1: Overview</p><p style="padding-left: 57pt;text-indent: 0pt;text-align: left;"><span/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s3" style="padding-left: 235pt;text-indent: 0pt;text-align: left;">4 T<span class="s4">ESTING</span></p><p style="padding-top: 12pt;padding-left: 6pt;text-indent: -1pt;line-height: 114%;text-align: center;">I have tested my reaction time at least 50 times. 10 of which are listed in fig. 4.1 below. I usually land somewhere between 0.23 sec and 0.28 sec. My best result is 0.21 sec and I finally had to give up on trying to break the 0.2 sec mark. I also tested with my flat mates and various friend with results varying from 0.20 sec to 0.53 sec. All the test subjects were in there 20s, it would be interesting to test with someone older to see if response time really decays with age.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: center;">Figure 4.1: 10 of my response times</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span/></p><p style="padding-top: 6pt;padding-left: 113pt;text-indent: 0pt;text-align: left;">responce time in seconds</p><p style="text-indent: 0pt;text-align: left;"/><p style="padding-top: 4pt;padding-left: 144pt;text-indent: 0pt;text-align: left;">0.3</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 138pt;text-indent: 0pt;text-align: left;">0.28</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 138pt;text-indent: 0pt;text-align: left;">0.26</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 138pt;text-indent: 0pt;text-align: left;">0.24</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 138pt;text-indent: 0pt;text-align: left;">0.22</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 144pt;text-indent: 0pt;line-height: 11pt;text-align: left;">0.2</p><p style="padding-left: 178pt;text-indent: 0pt;line-height: 11pt;text-align: left;">1  2  3  4  5  6  7  8  9  10</p><p class="s3" style="padding-top: 3pt;padding-left: 159pt;text-indent: 0pt;text-align: left;">5 F<span class="s4">INAL REMARKS AND CONCLUSION</span></p><p style="padding-top: 12pt;padding-left: 5pt;text-indent: 0pt;line-height: 114%;text-align: center;">After project 2 I had all but given up on my DE0 board. The switches did not work and the 7 segment screen flickered intermittently. I tested it with different code and determined it was a hardware issue and I just got a lemon. Before throwing in the towel and buying a new board I though I would try one last thing. After stripping the board down I put it in the oven for 8 minutes at 380 F to try re-flow the solder. I would say this is crazy but it worked. After letting the board cool down and reassembling it worked like new. As far as the project itself goes I found this one easier than project 2. Everything was straight forward, event the random number generator which I thought would be a challenge didn’t take to long. Last semester I took the digital clock project class where I used a physical 7400 series counter chip to step down a 32 kHz clock from a RTC crystal and all I have to say is the process of making an equivalent circuit in verilog &quot;software&quot; is so much simpler and less hassle. I’m glad that I can finally present you with a project that is up to my standards.</p></body></html>
